---
title: "컬렉션 프레임워크의 핵심: List 인터페이스 완벽 분석 "
excerpt: "자바의 정석"
categories:
  - Java
tags:
    - [Java]
permalink: /java/java_study_2025_1_2_1/
toc: true
toc_sticky: true
date: 2025-01-02
last_modified_at: 2025-01-02
---





<h1>제목: 스택, 큐, 우선순위 큐, 데크</h1>





**1. 스택(Stack)**

스택은 **LIFO(Last-In-First-Out)**, 즉 후입선출(後入先出) 방식을 따르는 자료구조입니다. 마치 책을 쌓아 올리는 것처럼, 가장 마지막에 들어온 데이터가 가장 먼저 나가게 됩니다.

**1.1. 스택의 주요 특징**

*   **LIFO (Last-In-First-Out)**: 가장 최근에 추가된 요소가 가장 먼저 제거됩니다.
*   **단방향 접근**: 데이터 삽입과 삭제가 한 쪽 끝(Top)에서만 이루어집니다.
*   **제한적 접근**: 중간에 있는 요소에는 직접 접근할 수 없습니다.

**1.2. 스택의 주요 메서드**

*   `push(E item)`: 스택의 맨 위에 요소를 추가합니다.<br/>

*   `pop()`: 스택의 맨 위에 있는 요소를 제거하고 반환합니다. 스택이 비어있으면 `EmptyStackException`을 발생시킵니다.
*   `peek()`: 스택의 맨 위에 있는 요소를 반환하지만, 스택에서 제거하지는 않습니다. 스택이 비어있으면 `EmptyStackException`을 발생시킵니다.
*   `empty()`: 스택이 비어있는지 확인합니다. 비어있다면 `true`, 비어있지 않다면 `false`를 반환합니다.
*   `search(Object o)`: 스택에서 주어진 객체를 찾아, 스택의 맨 위에서부터의 상대적인 위치를 반환합니다. 만약 찾지 못하면 `-1`을 반환합니다.

**1.3 스택의 활용 예시**

*   **함수 호출 스택**: 프로그램이 함수를 호출할 때마다 함수의 실행 정보가 스택에 저장됩니다. 함수 실행이 끝나면 스택에서 제거됩니다.<br/>

*   **괄호 검사**: 수식에서 괄호 쌍이 올바르게 사용되었는지 검사할 때, 스택을 사용하여 여는 괄호를 만나면 스택에 넣고 닫는 괄호를 만나면 스택에서 빼내어 비교합니다.
*   **웹 브라우저 방문 기록**: 사용자가 방문한 웹페이지들을 스택에 저장하여, 이전 페이지로 이동하는 기능을 구현할 수 있습니다.
* **실행 취소(Undo) 기능**:  편집기에서 사용자의 작업 기록을 스택에 저장하고, 실행 취소 기능을 구현하는 데 사용됩니다.

```java
Stack<Integer> stack = new Stack<>();
stack.push(1);
stack.push(2);
stack.push(3);
System.out.println(stack.pop());  // 출력: 3
System.out.println(stack.peek()); // 출력: 2
System.out.println(stack.search(1)); // 출력: 3
```

**2. 큐(Queue): FIFO의 질서**

큐는 **FIFO(First-In-First-Out)**, 즉 선입선출(先入先出) 원칙에 따라 데이터를 저장하고 관리하는 자료구조입니다. 마치 줄을 서서 기다리는 것처럼, 먼저 들어온 데이터가 먼저 나가게 됩니다.

**2.1. 큐의 주요 특징**
*   **FIFO (First-In-First-Out)**: 가장 먼저 추가된 요소가 가장 먼저 제거됩니다.<br/>

*  **양쪽 끝 접근**: 데이터 삽입은 한쪽 끝(rear)에서, 데이터 삭제는 다른 쪽 끝(front)에서 이루어집니다.
*   **제한적인 접근**: 큐의 중간에 있는 요소에는 직접 접근할 수 없습니다.

**2.2. 큐의 주요 메서드**

*   `offer(E e)`: 큐의 맨 뒤에 요소를 추가합니다.<br/>

*   `poll()`: 큐의 맨 앞에 있는 요소를 제거하고 반환합니다. 큐가 비어있으면 `null`을 반환합니다.
*   `peek()`: 큐의 맨 앞에 있는 요소를 반환하지만, 큐에서 제거하지 않습니다. 큐가 비어있으면 `null`을 반환합니다.
*  `element()`: 큐의 맨 앞에 있는 요소를 반환하지만, 큐에서 제거하지 않습니다. 큐가 비어 있으면 `NoSuchElementException` 예외를 발생시킵니다.
*  `remove()`: 큐의 맨 앞에 있는 요소를 제거하고 반환합니다. 큐가 비어 있으면 `NoSuchElementException` 예외를 발생시킵니다.

**2.3 큐의 활용 예시**

*   **작업 스케줄링**: 운영체제에서 프로세스를 스케줄링할 때 큐를 사용하여 먼저 들어온 프로세스를 먼저 처리할 수 있습니다.<br/>

*   **데이터 버퍼링**: 데이터를 생성하는 속도와 처리하는 속도가 다를 경우, 데이터를 큐에 저장하여 처리 속도를 맞춰줄 수 있습니다.
*   **메시지 큐**: 메시지를 순서대로 처리해야 할 때 큐를 사용하여 메시지를 저장하고 순차적으로 처리할 수 있습니다.
*   **프린터 대기열**: 여러 사용자가 동시에 프린터를 사용할 때, 출력 요청을 큐에 저장하여 순서대로 처리할 수 있습니다.

```java
Queue<String> queue = new LinkedList<>();
queue.offer("A");
queue.offer("B");
queue.offer("C");
System.out.println(queue.poll()); // 출력: A
System.out.println(queue.peek()); // 출력: B
System.out.println(queue.element()); // 출력: B
```

**3. 우선순위 큐 (Priority Queue)**
우선순위 큐는 큐의 일종이지만, 요소의 우선순위에 따라 정렬된 상태로 데이터를 저장합니다. `poll()` 메서드를 호출하면 우선순위가 가장 높은 요소가 반환됩니다.

**3.1. 우선순위 큐의 주요 특징**
*   **우선순위 기반**: 요소의 우선순위에 따라 정렬됩니다.<br/>

*   **힙(Heap) 자료구조**: 내부적으로 힙 자료구조를 사용하여 구현됩니다.
*   **`null` 불허**: `null` 값 저장 불가,  저장하면 NullPointerException 발생합니다.
*   **정렬 방식**:
    *   기본적으로 숫자는 오름차순, 문자는 사전순으로 정렬됩니다.<br/>

    *   `Comparator`를 사용하여 사용자 정의 정렬 기준을 정의할 수 있습니다.

**3.2. 우선순위 큐의 주요 메서드**
*   `offer(E e)`: 큐에 요소를 추가합니다.<br/>

*   `poll()`: 큐에서 우선순위가 가장 높은 요소를 제거하고 반환합니다.
*   `peek()`: 큐에서 우선순위가 가장 높은 요소를 반환하지만, 큐에서 제거하지는 않습니다.
*   `element()`: 큐에서 우선순위가 가장 높은 요소를 반환하지만, 큐에서 제거하지는 않습니다. 큐가 비어있다면 `NoSuchElementException` 예외를 던집니다.
*   `remove()` : 큐에서 우선순위가 가장 높은 요소를 제거하고 반환합니다. 큐가 비어있다면 `NoSuchElementException` 예외를 던집니다.

**3.3. 우선순위 큐의 활용 예시**

*   **작업 스케줄링**: 우선순위가 높은 작업을 먼저 처리해야 할 때, 우선순위 큐를 사용할 수 있습니다.<br/>

*   **네트워크 라우팅**: 네트워크 패킷을 우선순위에 따라 처리해야 할 때 사용할 수 있습니다.
*  **허프만 코딩**: 우선순위 큐를 사용하여 최소 빈도수의 문자를 찾아 최적의 코드를 생성할 수 있습니다.

```java
 PriorityQueue<Integer> pq = new PriorityQueue<>();
 pq.offer(3);
 pq.offer(1);
 pq.offer(2);
 System.out.println(pq.poll()); // 출력: 1
```

**4. 데크 (Deque)**

데크 (Deque)는 **Double-Ended Queue**의 약자로, 큐의 양쪽 끝에서 모두 데이터 삽입 및 삭제가 가능한 자료구조입니다. 스택과 큐의 기능을 모두 제공하는 유연한 자료구조입니다.

**4.1. 데크의 주요 특징**
*  **양방향 접근**: 양쪽 끝에서 모두 요소 삽입 및 삭제가 가능합니다.<br/>

*   **스택/큐 활용**: 스택 또는 큐처럼 사용할 수 있습니다.
*   **가변 크기**: 필요에 따라 크기가 동적으로 조절됩니다.

**4.2. 데크의 주요 메서드**
*   `offerFirst(E e)`: 데크의 맨 앞에 요소를 추가합니다.<br/>

*   `offerLast(E e)`: 데크의 맨 뒤에 요소를 추가합니다.
*   `pollFirst()`: 데크의 맨 앞에 있는 요소를 제거하고 반환합니다.
*   `pollLast()`: 데크의 맨 뒤에 있는 요소를 제거하고 반환합니다.
*   `peekFirst()`: 데크의 맨 앞에 있는 요소를 반환하지만, 제거하지는 않습니다.
*   `peekLast()`: 데크의 맨 뒤에 있는 요소를 반환하지만, 제거하지 않습니다.
*   `push(E e)`: 데크의 맨 앞에 요소를 추가합니다. (스택처럼 사용)
*   `pop()`: 데크의 맨 앞에 있는 요소를 제거하고 반환합니다. (스택처럼 사용)

**4.3. 데크의 활용 예시**

*   **스택과 큐의 조합**: 특정 상황에서는 스택처럼 사용하고, 다른 상황에서는 큐처럼 사용해야 할 때, 데크를 사용하면 코드를 단순화할 수 있습니다.<br/>

*   **작업 처리**: 작업 목록의 앞이나 뒤에서 작업을 추가하거나 제거해야 할 때 사용할 수 있습니다.
*   **히스토리 관리**: 최근 사용 목록 등을 관리하는 경우
*   **텍스트 에디터**: 텍스트 에디터에서 실행 취소(`undo`) 및 재실행(`redo`) 기능을 구현할 때 데크를 사용할 수 있습니다.

```java
 Deque<String> deque = new LinkedList<>();
 deque.offerFirst("A");
 deque.offerLast("B");
 System.out.println(deque.pollFirst()); // 출력: A
 System.out.println(deque.pollLast()); // 출력: B
```

**5. `LinkedList`를 이용한 구현**
`LinkedList`는 `Deque` 인터페이스를 구현하고 있기 때문에 `LinkedList`를 사용하여 스택 또는 큐처럼 사용할 수 있습니다.

```java
LinkedList<Integer> stackList = new LinkedList<>();
stackList.push(1);
stackList.push(2);
System.out.println(stackList.pop()); // 출력: 2
LinkedList<Integer> queueList = new LinkedList<>();
queueList.offer(1);
queueList.offer(2);
System.out.println(queueList.poll()); // 출력: 1
```
